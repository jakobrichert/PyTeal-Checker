import sklearn
import pandas as pd
from sklearn.naive_bayes import MultinomialNB
from sklearn.feature_extraction.text import CountVectorizer
import numpy
#Here is the data for the smart contracts, the first element is an array of secure pyteal smart contracts
#The second element is unsecure or wrongly formatted smart contracts
def main(new_data):
    data = [['from pyteal import *  """Atomic Swap"""  alice = Addr("6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY") bob = Addr("7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M") secret = Bytes("base32", "2323232323232323") timeout = 3000   def htlc(     tmpl_seller=alice,     tmpl_buyer=bob,     tmpl_fee=1000,     tmpl_secret=secret,     tmpl_hash_fn=Sha256,     tmpl_timeout=timeout, ):      fee_cond = Txn.fee() < Int(tmpl_fee)     safety_cond = And(         Txn.type_enum() == TxnType.Payment,         Txn.close_remainder_to() == Global.zero_address(),         Txn.rekey_to() == Global.zero_address(),     )      recv_cond = And(Txn.receiver() == tmpl_seller, tmpl_hash_fn(Arg(0)) == tmpl_secret)      esc_cond = And(Txn.receiver() == tmpl_buyer, Txn.first_valid() > Int(tmpl_timeout))      return And(fee_cond, safety_cond, Or(recv_cond, esc_cond))   if __name__ == "__main__":     print(compileTeal(htlc(), mode=Mode.Signature, version=2))',
    'from pyteal import *  ""Split Payment""  tmpl_fee = Int(1000) tmpl_rcv1 = Addr("6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY") tmpl_rcv2 = Addr("7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M") tmpl_own = Addr("5MK5NGBRT5RL6IGUSYDIX5P7TNNZKRVXKT6FGVI6UVK6IZAWTYQGE4RZIQ") tmpl_ratn = Int(1) tmpl_ratd = Int(3) tmpl_min_pay = Int(1000) tmpl_timeout = Int(3000)   def split(     tmpl_fee=tmpl_fee,     tmpl_rcv1=tmpl_rcv1,     tmpl_rcv2=tmpl_rcv2,     tmpl_own=tmpl_own,     tmpl_ratn=tmpl_ratn,     tmpl_ratd=tmpl_ratd,     tmpl_min_pay=tmpl_min_pay,     tmpl_timeout=tmpl_timeout, ):      split_core = And(         Txn.type_enum() == TxnType.Payment,         Txn.fee() < tmpl_fee,         Txn.rekey_to() == Global.zero_address(),     )      split_transfer = And(         Gtxn[0].sender() == Gtxn[1].sender(),         Txn.close_remainder_to() == Global.zero_address(),         Gtxn[0].receiver() == tmpl_rcv1,         Gtxn[1].receiver() == tmpl_rcv2,         Gtxn[0].amount()         == ((Gtxn[0].amount() + Gtxn[1].amount()) * tmpl_ratn) / tmpl_ratd,         Gtxn[0].amount() == tmpl_min_pay,     )      split_close = And(         Txn.close_remainder_to() == tmpl_own,         Txn.receiver() == Global.zero_address(),         Txn.amount() == Int(0),         Txn.first_valid() > tmpl_timeout,     )      split_program = And(         split_core, If(Global.group_size() == Int(2), split_transfer, split_close)     )      return split_program   if __name__ == "__main__":     print(compileTeal(split(), mode=Mode.Signature, version=2))',
    'from pyteal import *  ""Periodic Payment""  tmpl_fee = Int(1000) tmpl_period = Int(50) tmpl_dur = Int(5000) tmpl_lease = Bytes("base64", "023sdDE2") tmpl_amt = Int(2000) tmpl_rcv = Addr("6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY") tmpl_timeout = Int(30000)   def periodic_payment(     tmpl_fee=tmpl_fee,     tmpl_period=tmpl_period,     tmpl_dur=tmpl_dur,     tmpl_lease=tmpl_lease,     tmpl_amt=tmpl_amt,     tmpl_rcv=tmpl_rcv,     tmpl_timeout=tmpl_timeout, ):      periodic_pay_core = And(         Txn.type_enum() == TxnType.Payment,         Txn.fee() < tmpl_fee,         Txn.first_valid() % tmpl_period == Int(0),         Txn.last_valid() == tmpl_dur + Txn.first_valid(),         Txn.lease() == tmpl_lease,     )      periodic_pay_transfer = And(         Txn.close_remainder_to() == Global.zero_address(),         Txn.rekey_to() == Global.zero_address(),         Txn.receiver() == tmpl_rcv,         Txn.amount() == tmpl_amt,     )      periodic_pay_close = And(         Txn.close_remainder_to() == tmpl_rcv,         Txn.rekey_to() == Global.zero_address(),         Txn.receiver() == Global.zero_address(),         Txn.first_valid() == tmpl_timeout,         Txn.amount() == Int(0),     )      periodic_pay_escrow = periodic_pay_core.And(         periodic_pay_transfer.Or(periodic_pay_close)     )      return periodic_pay_escrow   if __name__ == "__main__":     print(compileTeal(periodic_payment(), mode=Mode.Signature, version=2))',
    'from pyteal import *   def approval_program():     on_creation = Seq(         [             App.globalPut(Bytes("Creator"), Txn.sender()),             Assert(Txn.application_args.length() == Int(4)),             App.globalPut(Bytes("RegBegin"), Btoi(Txn.application_args[0])),             App.globalPut(Bytes("RegEnd"), Btoi(Txn.application_args[1])),             App.globalPut(Bytes("VoteBegin"), Btoi(Txn.application_args[2])),             App.globalPut(Bytes("VoteEnd"), Btoi(Txn.application_args[3])),             Return(Int(1)),         ]     )      is_creator = Txn.sender() == App.globalGet(Bytes("Creator"))      get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes("voted"))      on_closeout = Seq(         [             get_vote_of_sender,             If(                 And(                     Global.round() <= App.globalGet(Bytes("VoteEnd")),                     get_vote_of_sender.hasValue(),                 ),                 App.globalPut(                     get_vote_of_sender.value(),                     App.globalGet(get_vote_of_sender.value()) - Int(1),                 ),             ),             Return(Int(1)),         ]     )      on_register = Return(         And(             Global.round() >= App.globalGet(Bytes("RegBegin")),             Global.round() <= App.globalGet(Bytes("RegEnd")),         )     )      choice = Txn.application_args[1]     choice_tally = App.globalGet(choice)     on_vote = Seq(         [             Assert(                 And(                     Global.round() >= App.globalGet(Bytes("VoteBegin")),                     Global.round() <= App.globalGet(Bytes("VoteEnd")),                 )             ),             get_vote_of_sender,             If(get_vote_of_sender.hasValue(), Return(Int(0))),             App.globalPut(choice, choice_tally + Int(1)),             App.localPut(Int(0), Bytes("voted"), choice),             Return(Int(1)),         ]     )      program = Cond(         [Txn.application_id() == Int(0), on_creation],         [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_creator)],         [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_creator)],         [Txn.on_completion() == OnComplete.CloseOut, on_closeout],         [Txn.on_completion() == OnComplete.OptIn, on_register],         [Txn.application_args[0] == Bytes("vote"), on_vote],     )      return program   def clear_state_program():     get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes("voted"))     program = Seq(         [             get_vote_of_sender,             If(                 And(                     Global.round() <= App.globalGet(Bytes("VoteEnd")),                     get_vote_of_sender.hasValue(),                 ),                 App.globalPut(                     get_vote_of_sender.value(),                     App.globalGet(get_vote_of_sender.value()) - Int(1),                 ),             ),             Return(Int(1)),         ]     )      return program   if __name__ == "__main__":     with open(vote_approval.teal, w) as f:         compiled = compileTeal(approval_program(), mode=Mode.Application, version=2)         f.write(compiled)      with open("vote_clear_state.teal", "w") as f:         compiled = compileTeal(clear_state_program(), mode=Mode.Application, version=2)         f.write(compiled)',
    'from pyteal import *   def approval_program():     on_creation = Seq(         [             Assert(Txn.application_args.length() == Int(1)),             App.globalPut(Bytes("total supply"), Btoi(Txn.application_args[0])),             App.globalPut(Bytes("reserve"), Btoi(Txn.application_args[0])),             App.localPut(Int(0), Bytes("admin"), Int(1)),             App.localPut(Int(0), Bytes("balance"), Int(0)),             Return(Int(1)),         ]     )      is_admin = App.localGet(Int(0), Bytes("admin"))      on_closeout = Seq(         [             App.globalPut(                 Bytes("reserve"),                 App.globalGet(Bytes("reserve"))                 + App.localGet(Int(0), Bytes("balance")),             ),             Return(Int(1)),         ]     )      register = Seq([App.localPut(Int(0), Bytes("balance"), Int(0)), Return(Int(1))])      # configure the admin status of the account Txn.accounts[1]     # sender must be admin     new_admin_status = Btoi(Txn.application_args[1])     set_admin = Seq(         [             Assert(And(is_admin, Txn.application_args.length() == Int(2))),             App.localPut(Int(1), Bytes("admin"), new_admin_status),             Return(Int(1)),         ]     )     # NOTE: The above set_admin code is carefully constructed. If instead we used the following code:     # Seq([     #     Assert(Txn.application_args.length() == Int(2)),     #     App.localPut(Int(1), Bytes("admin"), new_admin_status),     #     Return(is_admin)     # ])     # It would be vulnerable to the following attack: a sender passes in their own address as     # Txn.accounts[1], so then the line App.localPut(Int(1), Bytes("admin"), new_admin_status)     # changes the senders admin status, meaning the final Return(is_admin) can return anything the     # sender wants. This allows anyone to become an admin!      # move assets from the reserve to Txn.accounts[1]     # sender must be admin     mint_amount = Btoi(Txn.application_args[1])     mint = Seq(         [             Assert(Txn.application_args.length() == Int(2)),             Assert(mint_amount <= App.globalGet(Bytes("reserve"))),             App.globalPut(                 Bytes("reserve"), App.globalGet(Bytes("reserve")) - mint_amount             ),             App.localPut(                 Int(1),                 Bytes("balance"),                 App.localGet(Int(1), Bytes("balance")) + mint_amount,             ),             Return(is_admin),         ]     )      # transfer assets from the sender to Txn.accounts[1]     transfer_amount = Btoi(Txn.application_args[1])     transfer = Seq(         [             Assert(Txn.application_args.length() == Int(2)),             Assert(transfer_amount <= App.localGet(Int(0), Bytes("balance"))),             App.localPut(                 Int(0),                 Bytes("balance"),                 App.localGet(Int(0), Bytes("balance")) - transfer_amount,             ),             App.localPut(                 Int(1),                 Bytes("balance"),                 App.localGet(Int(1), Bytes("balance")) + transfer_amount,             ),             Return(Int(1)),         ]     )      program = Cond(         [Txn.application_id() == Int(0), on_creation],         [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_admin)],         [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_admin)],         [Txn.on_completion() == OnComplete.CloseOut, on_closeout],         [Txn.on_completion() == OnComplete.OptIn, register],         [Txn.application_args[0] == Bytes("set admin"), set_admin],         [Txn.application_args[0] == Bytes("mint"), mint],         [Txn.application_args[0] == Bytes("transfer"), transfer],     )      return program   def clear_state_program():     program = Seq(         [             App.globalPut(                 Bytes("reserve"),                 App.globalGet(Bytes("reserve"))                 + App.localGet(Int(0), Bytes("balance")),             ),             Return(Int(1)),         ]     )      return program   if __name__ == "__main__":     with open("asset_approval.teal", "w") as f:         compiled = compileTeal(approval_program(), mode=Mode.Application, version=2)         f.write(compiled)      with open("asset_clear_state.teal", "w") as f:         compiled = compileTeal(clear_state_program(), mode=Mode.Application, version=2)         f.write(compiled)'
    'from pyteal import *  ""Atomic Swap""  alice = Addr("6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY") bob = Addr("7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M") secret = Bytes("base32", "2323232323232323") timeout = 3000   def htlc(     tmpl_seller=alice,     tmpl_buyer=bob,     tmpl_fee=1000,     tmpl_secret=secret,     tmpl_hash_fn=Sha256,     tmpl_timeout=timeout, ):      fee_cond = Txn.fee() < Int(tmpl_fee)     safety_cond = And(         Txn.type_enum() == TxnType.Payment,         Txn.close_remainder_to() == Global.zero_address(),         Txn.rekey_to() == Global.zero_address(),     )      recv_cond = And(Txn.receiver() == tmpl_seller, tmpl_hash_fn(Arg(0)) == tmpl_secret)      esc_cond = And(Txn.receiver() == tmpl_buyer, Txn.first_valid() > Int(tmpl_timeout))      return And(fee_cond, safety_cond, Or(recv_cond, esc_cond))   if __name__ == "__main__":     print(compileTeal(htlc(), mode=Mode.Signature, version=2))',
    'from pyteal import *  ""Split Payment""  tmpl_fee = Int(1000) tmpl_rcv1 = Addr("6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY") tmpl_rcv2 = Addr("7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M") tmpl_own = Addr("5MK5NGBRT5RL6IGUSYDIX5P7TNNZKRVXKT6FGVI6UVK6IZAWTYQGE4RZIQ") tmpl_ratn = Int(1) tmpl_ratd = Int(3) tmpl_min_pay = Int(1000) tmpl_timeout = Int(3000)   def split(     tmpl_fee=tmpl_fee,     tmpl_rcv1=tmpl_rcv1,     tmpl_rcv2=tmpl_rcv2,     tmpl_own=tmpl_own,     tmpl_ratn=tmpl_ratn,     tmpl_ratd=tmpl_ratd,     tmpl_min_pay=tmpl_min_pay,     tmpl_timeout=tmpl_timeout, ):      split_core = And(         Txn.type_enum() == TxnType.Payment,         Txn.fee() < tmpl_fee,         Txn.rekey_to() == Global.zero_address(),     )      split_transfer = And(         Gtxn[0].sender() == Gtxn[1].sender(),         Txn.close_remainder_to() == Global.zero_address(),         Gtxn[0].receiver() == tmpl_rcv1,         Gtxn[1].receiver() == tmpl_rcv2,         Gtxn[0].amount()         == ((Gtxn[0].amount() + Gtxn[1].amount()) * tmpl_ratn) / tmpl_ratd,         Gtxn[0].amount() == tmpl_min_pay,     )      split_close = And(         Txn.close_remainder_to() == tmpl_own,         Txn.receiver() == Global.zero_address(),         Txn.amount() == Int(0),         Txn.first_valid() > tmpl_timeout,     )      split_program = And(         split_core, If(Global.group_size() == Int(2), split_transfer, split_close)     )      return split_program   if __name__ == "__main__":     print(compileTeal(split(), mode=Mode.Signature, version=2))',
    'from pyteal import *  ""Periodic Payment""  tmpl_fee = Int(1000) tmpl_period = Int(50) tmpl_dur = Int(5000) tmpl_lease = Bytes("base64", "023sdDE2") tmpl_amt = Int(2000) tmpl_rcv = Addr("6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY") tmpl_timeout = Int(30000)   def periodic_payment(     tmpl_fee=tmpl_fee,     tmpl_period=tmpl_period,     tmpl_dur=tmpl_dur,     tmpl_lease=tmpl_lease,     tmpl_amt=tmpl_amt,     tmpl_rcv=tmpl_rcv,     tmpl_timeout=tmpl_timeout, ):      periodic_pay_core = And(         Txn.type_enum() == TxnType.Payment,         Txn.fee() < tmpl_fee,         Txn.first_valid() % tmpl_period == Int(0),         Txn.last_valid() == tmpl_dur + Txn.first_valid(),         Txn.lease() == tmpl_lease,     )      periodic_pay_transfer = And(         Txn.close_remainder_to() == Global.zero_address(),         Txn.rekey_to() == Global.zero_address(),         Txn.receiver() == tmpl_rcv,         Txn.amount() == tmpl_amt,     )      periodic_pay_close = And(         Txn.close_remainder_to() == tmpl_rcv,         Txn.rekey_to() == Global.zero_address(),         Txn.receiver() == Global.zero_address(),         Txn.first_valid() == tmpl_timeout,         Txn.amount() == Int(0),     )      periodic_pay_escrow = periodic_pay_core.And(         periodic_pay_transfer.Or(periodic_pay_close)     )      return periodic_pay_escrow   if __name__ == "__main__":     print(compileTeal(periodic_payment(), mode=Mode.Signature, version=2))',
    'from pyteal import *   def approval_program():     on_creation = Seq(         [             App.globalPut(Bytes("Creator"), Txn.sender()),             Assert(Txn.application_args.length() == Int(4)),             App.globalPut(Bytes("RegBegin"), Btoi(Txn.application_args[0])),             App.globalPut(Bytes("RegEnd"), Btoi(Txn.application_args[1])),             App.globalPut(Bytes("VoteBegin"), Btoi(Txn.application_args[2])),             App.globalPut(Bytes("VoteEnd"), Btoi(Txn.application_args[3])),             Return(Int(1)),         ]     )      is_creator = Txn.sender() == App.globalGet(Bytes("Creator"))      get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes("voted"))      on_closeout = Seq(         [             get_vote_of_sender,             If(                 And(                     Global.round() <= App.globalGet(Bytes("VoteEnd")),                     get_vote_of_sender.hasValue(),                 ),                 App.globalPut(                     get_vote_of_sender.value(),                     App.globalGet(get_vote_of_sender.value()) - Int(1),                 ),             ),             Return(Int(1)),         ]     )      on_register = Return(         And(             Global.round() >= App.globalGet(Bytes("RegBegin")),             Global.round() <= App.globalGet(Bytes("RegEnd")),         )     )      choice = Txn.application_args[1]     choice_tally = App.globalGet(choice)     on_vote = Seq(         [             Assert(                 And(                     Global.round() >= App.globalGet(Bytes("VoteBegin")),                     Global.round() <= App.globalGet(Bytes("VoteEnd")),                 )             ),             get_vote_of_sender,             If(get_vote_of_sender.hasValue(), Return(Int(0))),             App.globalPut(choice, choice_tally + Int(1)),             App.localPut(Int(0), Bytes("voted"), choice),             Return(Int(1)),         ]     )      program = Cond(         [Txn.application_id() == Int(0), on_creation],         [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_creator)],         [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_creator)],         [Txn.on_completion() == OnComplete.CloseOut, on_closeout],         [Txn.on_completion() == OnComplete.OptIn, on_register],         [Txn.application_args[0] == Bytes("vote"), on_vote],     )      return program   def clear_state_program():     get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes("voted"))     program = Seq(         [             get_vote_of_sender,             If(                 And(                     Global.round() <= App.globalGet(Bytes("VoteEnd")),                     get_vote_of_sender.hasValue(),                 ),                 App.globalPut(                     get_vote_of_sender.value(),                     App.globalGet(get_vote_of_sender.value()) - Int(1),                 ),             ),             Return(Int(1)),         ]     )      return program   if __name__ == "__main__":     with open(vote_approval.teal, w) as f:         compiled = compileTeal(approval_program(), mode=Mode.Application, version=2)         f.write(compiled)      with open("vote_clear_state.teal", "w") as f:         compiled = compileTeal(clear_state_program(), mode=Mode.Application, version=2)         f.write(compiled)',
    'from pyteal import *   def approval_program():     on_creation = Seq(         [             Assert(Txn.application_args.length() == Int(1)),             App.globalPut(Bytes("total supply"), Btoi(Txn.application_args[0])),             App.globalPut(Bytes("reserve"), Btoi(Txn.application_args[0])),             App.localPut(Int(0), Bytes("admin"), Int(1)),             App.localPut(Int(0), Bytes("balance"), Int(0)),             Return(Int(1)),         ]     )      is_admin = App.localGet(Int(0), Bytes("admin"))      on_closeout = Seq(         [             App.globalPut(                 Bytes("reserve"),                 App.globalGet(Bytes("reserve"))                 + App.localGet(Int(0), Bytes("balance")),             ),             Return(Int(1)),         ]     )      register = Seq([App.localPut(Int(0), Bytes("balance"), Int(0)), Return(Int(1))])      # configure the admin status of the account Txn.accounts[1]     # sender must be admin     new_admin_status = Btoi(Txn.application_args[1])     set_admin = Seq(         [             Assert(And(is_admin, Txn.application_args.length() == Int(2))),             App.localPut(Int(1), Bytes("admin"), new_admin_status),             Return(Int(1)),         ]     )     # NOTE: The above set_admin code is carefully constructed. If instead we used the following code:     # Seq([     #     Assert(Txn.application_args.length() == Int(2)),     #     App.localPut(Int(1), Bytes("admin"), new_admin_status),     #     Return(is_admin)     # ])     # It would be vulnerable to the following attack: a sender passes in their own address as     # Txn.accounts[1], so then the line App.localPut(Int(1), Bytes("admin"), new_admin_status)     # changes the senders admin status, meaning the final Return(is_admin) can return anything the     # sender wants. This allows anyone to become an admin!      # move assets from the reserve to Txn.accounts[1]     # sender must be admin     mint_amount = Btoi(Txn.application_args[1])     mint = Seq(         [             Assert(Txn.application_args.length() == Int(2)),             Assert(mint_amount <= App.globalGet(Bytes("reserve"))),             App.globalPut(                 Bytes("reserve"), App.globalGet(Bytes("reserve")) - mint_amount             ),             App.localPut(                 Int(1),                 Bytes("balance"),                 App.localGet(Int(1), Bytes("balance")) + mint_amount,             ),             Return(is_admin),         ]     )      # transfer assets from the sender to Txn.accounts[1]     transfer_amount = Btoi(Txn.application_args[1])     transfer = Seq(         [             Assert(Txn.application_args.length() == Int(2)),             Assert(transfer_amount <= App.localGet(Int(0), Bytes("balance"))),             App.localPut(                 Int(0),                 Bytes("balance"),                 App.localGet(Int(0), Bytes("balance")) - transfer_amount,             ),             App.localPut(                 Int(1),                 Bytes("balance"),                 App.localGet(Int(1), Bytes("balance")) + transfer_amount,             ),             Return(Int(1)),         ]     )      program = Cond(         [Txn.application_id() == Int(0), on_creation],         [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_admin)],         [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_admin)],         [Txn.on_completion() == OnComplete.CloseOut, on_closeout],         [Txn.on_completion() == OnComplete.OptIn, register],         [Txn.application_args[0] == Bytes("set admin"), set_admin],         [Txn.application_args[0] == Bytes("mint"), mint],         [Txn.application_args[0] == Bytes("transfer"), transfer],     )      return program   def clear_state_program():     program = Seq(         [             App.globalPut(                 Bytes("reserve"),                 App.globalGet(Bytes("reserve"))                 + App.localGet(Int(0), Bytes("balance")),             ),             Return(Int(1)),         ]     )      return program   if __name__ == "__main__":     with open("asset_approval.teal", "w") as f:         compiled = compileTeal(approval_program(), mode=Mode.Application, version=2)         f.write(compiled)      with open("asset_clear_state.teal", "w") as f:         compiled = compileTeal(clear_state_program(), mode=Mode.Application, version=2)         f.write(compiled)',
    
    ],


    ['from pyteal import *   def approval_program():     on_creation = Seq(         [             Assert(Txn.application_args.length() == Int(1)),             App.globalPut(Bytes("total supply"), Btoi(Txn.application_args[0])),             App.globalPut(Bytes("reserve"), Btoi(Txn.application_args[0])),             App.globalPut(Bytes("paused"), Int(0)),             App.localPut(Int(0), Bytes("contract admin"), Int(1)),             App.localPut(Int(0), Bytes("transfer admin"), Int(1)),             App.localPut(Int(0), Bytes("balance"), Int(0)),             Return(Int(1)),         ]     )      is_contract_admin = App.localGet(Int(0), Bytes("contract admin"))     is_transfer_admin = App.localGet(Int(0), Bytes("transfer admin"))     is_any_admin = is_contract_admin.Or(is_transfer_admin)      can_delete = And(         is_contract_admin,         App.globalGet(Bytes("total supply")) == App.globalGet(Bytes("reserve")),     )      on_closeout = Seq(         [             App.globalPut(                 Bytes("reserve"),                 App.globalGet(Bytes("reserve"))                 + App.localGet(Int(0), Bytes("balance")),             ),             Return(Int(1)),         ]     )      register = Seq([App.localPut(Int(0), Bytes("balance"), Int(0)), Return(Int(1))])      # pause all transfers     # sender must be any admin     new_pause_value = Btoi(Txn.application_args[1])     pause = Seq(         [             Assert(Txn.application_args.length() == Int(2)),             App.globalPut(Bytes("paused"), new_pause_value),             Return(is_any_admin),         ]     )      # configure the admin status of the account Txn.accounts[1]     # sender must be contract admin     new_admin_type = Txn.application_args[1]     new_admin_status = Btoi(Txn.application_args[2])     set_admin = Seq(         [             Assert(                 And(                     is_contract_admin,                     Txn.application_args.length() == Int(3),                     Or(                         new_admin_type == Bytes("contract admin"),                         new_admin_type == Bytes("transfer admin"),                     ),                     Txn.accounts.length() == Int(1),                 )             ),             App.localPut(Int(1), new_admin_type, new_admin_status),             Return(is_contract_admin),         ]     )  new_freeze_value = Btoi(Txn.application_args[1])     freeze = Seq(         [             Assert(                 And(                     Txn.application_args.length() == Int(2),                     Txn.accounts.length() == Int(1),                 )             ),             App.localPut(Int(1), Bytes("frozen"), new_freeze_value),             Return(is_any_admin),         ]     )   max_balance_value = Btoi(Txn.application_args[1])     max_balance = Seq(         [             Assert(                 And(                     Txn.application_args.length() == Int(2),                     Txn.accounts.length() == Int(1),                 )             ),             If(                 max_balance_value == Int(0),                 App.localDel(Int(1), Bytes("max balance")),                 App.localPut(Int(1), Bytes("max balance"), max_balance_value),             ),             Return(is_transfer_admin),         ]     )  lock_until_value = Btoi(Txn.application_args[1])     lock_until = Seq(         [             Assert(                 And(                     Txn.application_args.length() == Int(2),                     Txn.accounts.length() == Int(1),                 )             ),             If(                 lock_until_value == Int(0),                 App.localDel(Int(1), Bytes("lock until")),                 App.localPut(Int(1), Bytes("lock until"), lock_until_value),             ),             Return(is_transfer_admin),         ]     )      set_transfer_group = Seq(         [             Assert(                 And(                     Txn.application_args.length() == Int(3),                     Txn.accounts.length() == Int(1),                 )             ),             App.localPut(                 Int(1), Bytes("transfer group"), Btoi(Txn.application_args[2])             ),         ]     )   def getRuleKey(sendGroup, receiveGroup):         return Concat(Bytes("rule"), Itob(sendGroup), Itob(receiveGroup))      lock_transfer_key = getRuleKey(         Btoi(Txn.application_args[2]), Btoi(Txn.application_args[3])     )     lock_transfer_until = Btoi(Txn.application_args[4])     lock_transfer_group = Seq(         [             Assert(Txn.application_args.length() == Int(5)),             If(                 lock_transfer_until == Int(0),                 App.globalDel(lock_transfer_key),                 App.globalPut(lock_transfer_key, lock_transfer_until),             ),         ]     )      # sender must be transfer admin     transfer_group = Seq(         [             Assert(Txn.application_args.length() > Int(2)),             Cond(                 [Txn.application_args[1] == Bytes("set"), set_transfer_group],                 [Txn.application_args[1] == Bytes("lock"), lock_transfer_group],             ),             Return(is_transfer_admin),         ]     ) mint_amount = Btoi(Txn.application_args[1])     mint = Seq(         [             Assert(                 And(                     Txn.application_args.length() == Int(2),                     Txn.accounts.length() == Int(1),                     mint_amount <= App.globalGet(Bytes("reserve")),                 )             ),             App.globalPut(                 Bytes("reserve"), App.globalGet(Bytes("reserve")) - mint_amount             ),             App.localPut(                 Int(1),                 Bytes("balance"),                 App.localGet(Int(1), Bytes("balance")) + mint_amount,             ),             Return(is_contract_admin),         ]     ) burn_amount = Btoi(Txn.application_args[1])     burn = Seq(         [             Assert(                 And(                     Txn.application_args.length() == Int(2),                     Txn.accounts.length() == Int(1),                     burn_amount <= App.localGet(Int(1), Bytes("balance")),                 )             ),             App.globalPut(                 Bytes("reserve"), App.globalGet(Bytes("reserve")) + burn_amount             ),             App.localPut(                 Int(1),                 Bytes("balance"),                 App.localGet(Int(1), Bytes("balance")) - burn_amount,             ),             Return(is_contract_admin),         ]     )      # transfer assets from the sender to Txn.accounts[1]     transfer_amount = Btoi(Txn.application_args[1])     receiver_max_balance = App.localGetEx(Int(1), App.id(), Bytes("max balance"))     transfer = Seq(         [             Assert(                 And(                     Txn.application_args.length() == Int(2),                     Txn.accounts.length() == Int(1),                     transfer_amount <= App.localGet(Int(0), Bytes("balance")),                 )             ),             receiver_max_balance,             If(                 Or(                     App.globalGet(Bytes("paused")),                     App.localGet(Int(0), Bytes("frozen")),                     App.localGet(Int(1), Bytes("frozen")),                     App.localGet(Int(0), Bytes("lock until"))                     >= Global.latest_timestamp(),                     App.localGet(Int(1), Bytes("lock until"))                     >= Global.latest_timestamp(),                     App.globalGet(                         getRuleKey(                             App.localGet(Int(0), Bytes("transfer group")),                             App.localGet(Int(1), Bytes("transfer group")),                         )                     )                     >= Global.latest_timestamp(),                     And(                         receiver_max_balance.hasValue(),                         receiver_max_balance.value()                         < App.localGet(Int(1), Bytes("balance")) + transfer_amount,                     ),                 ),                 Return(Int(0)),             ),             App.localPut(                 Int(0),                 Bytes("balance"),                 App.localGet(Int(0), Bytes("balance")) - transfer_amount,             ),             App.localPut(                 Int(1),                 Bytes("balance"),                 App.localGet(Int(1), Bytes("balance")) + transfer_amount,             ),             Return(Int(1)),         ]     )      program = Cond(         [Txn.application_id() == Int(0), on_creation],         [Txn.on_completion() == OnComplete.DeleteApplication, Return(can_delete)],         [             Txn.on_completion() == OnComplete.UpdateApplication,             Return(is_contract_admin),         ],         [Txn.on_completion() == OnComplete.CloseOut, on_closeout],         [Txn.on_completion() == OnComplete.OptIn, register],         [Txn.application_args[0] == Bytes("pause"), pause],         [Txn.application_args[0] == Bytes("set admin"), set_admin],         [Txn.application_args[0] == Bytes("freeze"), freeze],         [Txn.application_args[0] == Bytes("max balance"), max_balance],         [Txn.application_args[0] == Bytes("lock until"), lock_until],         [Txn.application_args[0] == Bytes("transfer group"), transfer_group],         [Txn.application_args[0] == Bytes("mint"), mint],         [Txn.application_args[0] == Bytes("burn"), burn],         [Txn.application_args[0] == Bytes("transfer"), transfer],     )      return program   def clear_state_program():     program = Seq(         [             App.globalPut(                 Bytes("reserve"),                 App.globalGet(Bytes("reserve"))                 + App.localGet(Int(0), Bytes("balance")),             ),             Return(Int(1)),         ]     )      return program   if __name__ == "__main__":     with open("security_token_approval.teal", "w") as f:         compiled = compileTeal(approval_program(), mode=Mode.Application, version=2)',
    'pragma solidity 0.8.4;  import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./PmknToken.sol";  contract TokenFarm {      // userAddress => stakingBalance     mapping(address => uint256) public stakingBalance;     // userAddress => isStaking boolean     mapping(address => bool) public isStaking;     // userAddress => timeStamp     mapping(address => uint256) public startTime;     // userAddress => pmknBalance     mapping(address => uint256) public pmknBalance;      string public name = "TokenFarm";      IERC20 public daiToken;     PmknToken public pmknToken;      event Stake(address indexed from, uint256 amount);     event Unstake(address indexed from, uint256 amount);     event YieldWithdraw(address indexed to, uint256 amount);      constructor(         IERC20 _daiToken,         PmknToken _pmknToken         ) {             daiToken = _daiToken;             pmknToken = _pmknToken;         }      /// Core function shells     stake() public {}     unstake() public {}     withdrawYield() public {} }',
    'pragma solidity ^0.8.0;  import "@openzeppelin/contracts/token/ERC20/ERC20.sol";  contract MyToken is ERC20 {     constructor() public ERC20("MyToken", "MTKN"){         _mint(msg.sender, 1000000000000000000000000);     } } '
    '  set_admin = Seq([Assert(And(is_admin, Txn.application_args.length() == Int(2))),App.localPut(Int(1), Bytes("admin"), new_admin_status),Return(Int(1)),])'
    ]]
#Here are the labels we use to classify if a smart contract is secure or not
#1 means it is secure 0 means it is not
    labels =['1','0']

#initialize our vectorizer for counting words
    vec = CountVectorizer()
    X = vec.fit_transform([' '.join(row) for row in data])

# Initialize our classifier (we use a multinomialNB model for this)
#plans on refining the model and way we handle the data will change in the future
    mnb = MultinomialNB()

# Train our classifier
    mnb.fit(X, labels)
    new_data = [new_data,new_data]
#new data is what we are testing our model on 
    new_X = vec.transform([' '.join(new_data)])
    return mnb.predict(new_X)

